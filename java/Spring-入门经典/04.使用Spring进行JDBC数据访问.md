
### 使用普通 JDBC 带来的问题
* 链接数据库时的问题
    * 几乎所有的应用程序在其生命中都会需要处理数据，且一般来说都是访问关系型数据库；
        但是不同的关系型数据库有不同的查询和处理命令，因此就必须使用不同的方法来链接数据库；执行SQL操作；获取和处理查询结果。
    * JDBC 并没有对不同的数据库所提供的SQL符号进行完全抽象。即开发人员开发的数据库链接程序可以链接任何Oracle数据库，但是链接其他数据库就可能会出现问题。
    * 使用 JDBC 时一般都需要使用 try、catch、finally 关键字，而有时候单事务的复杂操作，会导致这几个关键字会分散到源文件的各个角落里，很难进行维护

### 引入 Spring 的 JDBC 支持
* Spring 主要通过三种方法来提供数据库访问操作
    * 使用基于 Template Method 模式的实用程序类（ JdbcTemplate 和 NamedParameterJdbcTemplate ）
    * 使用如 SimpleJdbcInsert 、 SimpleJdbcCall 之类的类以及数据库元数据，简化查询
    * 通过使用 MappingSqlQuery、SqlUpdate、 StoreProcedure 类，将数据库操作表示为可重复使用的 Java 对象。
        这样每次只需要提供不同的查询参数，就可以反复使用这些对象

* 管理 JDBC 连接
    * 一般有两种方式获取数据库链接
        * 第一种方法： DriverManager
        * 第二种方法： DataSource
            * 这种方式更好，因为DataSource是一个广义的连接工厂，它能让我们隐藏数据库连接参数、连接池以及来自应用程序的事务管理问题

* 配置简单的 DataSource 来获取 JDBC 链接
    * 这里使用 H2 数据库作为测试（注意，H2数据库并不适合线上使用，只是将其作为一个测试数据库即可）
    * 1. 首先启动 H2 数据库
    ```bash
    # 首先去官网下载 H2 的相关包，下载完毕之后解压
    $ unzip h2-2016-10-31.zip
    $ java -jar h2/bin/h2-1.4.193.jar
    # 执行上面的 java -jar 之后，将会启动浏览器，可以通过浏览器访问 H2 数据库，进行简单的操作
    ```
    * 2. 之后定义 DataSource Bean，可以采用下面两种方法中的任意一种
        * 方法1：使用 DriverManagerDataSource 对象，每次调用 getConnection 方法都将会返回一个新的链接
        ```java
        @Bean
        public DataSource dataSource() {
            DriverManagerDataSource dataSource = new DriverManagerDataSource();
            dataSource.setDriverClassName("org.h2.Driver");
            dataSource.setUrl("jdbc:h2:tcp://localhost/~/test");
            dataSource.setUsername("sa");
            dataSource.setPassword("");
            return dataSource;
        }
        ```
        * 方法2：使用 SingleConnectionDataSource 对象，每次调用 getConnection 都会返回相同的链接
        ```java
        @Bean
        public DataSource dataSource() {
            SingleConnectionDataSource dataSource = new SingleConnectionDataSource();
            // 通过 setSuppressClose(true) ，将会返回一个代理 Connection 实例，该实例会拦截 close 方法的调用
            dataSource.setSuppressClose(true);
            dataSource.setDriverClassName("org.h2.Driver");
            dataSource.setUrl("jdbc:h2:tcp://localhost/~/test");
            dataSource.setUsername("sa");
            dataSource.setPassword("");
            return dataSource;
        }
        ```
    * 3. 简单使用
    ```java
    AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(Ch4Configuration.class);
    DataSource dataSource = applicationContext.getBean("dataSource", DataSource.class);
    Connection connection = dataSource.getConnection();
    System.out.println(connection.isClosed());
    connection.close();
    System.out.println(connection.isClosed());
    ```
    * 注意，不要在生产环境中使用 DriverManagerDataSource，因为它没有连接池功能。最好使用具有连接池功能的 DataSource 实现，比如 C3P0

* 配置具有连接池功能的 DataSource 进行 JDBC 连接
    * 1. 首先启动 H2 数据库（同上）
    * 2. 之后定义 DataSource Bean，可以采用下面两种方法中的任意一种
        * 方法1： 使用 BasicDataSource
        ```xml
        <dependency>
            <groupId>commons-dbcp</groupId>
            <artifactId>commons-dbcp</artifactId>
            <version>1.4</version>
        </dependency>
        ```
        ```java
        @Bean(destroyMethod="close")
        public DataSource dataSource() {
            BasicDataSource dataSource = new BasicDataSource();
            dataSource.setDriverClassName("org.h2.Driver");
            dataSource.setUrl("jdbc:h2:tcp://localhost/~/test");
            dataSource.setUsername("sa");
            dataSource.setPassword("");
            return dataSource;
        }
        ```
        * 方法2： 使用 ComboPooledDataSource
        ```xml
        <dependency>
            <groupId>com.mchange</groupId>
            <artifactId>c3p0</artifactId>
            <version>0.9.2.1</version>
        </dependency>
        ```
        ```java
        @Bean(destroyMethod="close")
        public DataSource dataSource() throws Exception {
            ComboPooledDataSource dataSource = new ComboPooledDataSource();
            dataSource.setDriverClass("org.h2.Driver");
            dataSource.setJdbcUrl("jdbc:h2:tcp://localhost/~/test");
            dataSource.setUser("sa");
            dataSource.setPassword("");
            return dataSource;
        }
        ```
    * 3. 定义完毕 Bean 之后，可以进行一些配置，使得程序在启动的时候，进行数据库表的初始化以及表初始内容的插入
    ```xml
    <beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns:jdbc="http://www.springframework.org/schema/jdbc"
        xsi:schemaLocation="http://www.springframework.org/schema/beans 
            http://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/jdbc 
            http://www.springframework.org/schema/jdbc/spring-jdbc-4.0.xsd">
        <jdbc:embedded-database id="dataSource" type="H2"/>
        <!-- 
            对应用程序启动期间，使用一些 SQL 脚本来初始化数据库
            默认情况下，配置的两个 jdbc:script location 标签指定的 sql 文件在每次应用程序启动的时候都会被执行，
                因此加入 enabled="#{systemProperties.INIT_DB}" ，通过在系统属性或者环境变量中设置 INIT_DB 属性，来控制应用程序启动时是否执行sql语句
         -->
        <jdbc:initialize-database data-source="dataSource" enabled="#{systemProperties.INIT_DB}">
            <!-- 指定用来初始化数据库表的sql文件 -->
            <jdbc:script location="classpath:schema.sql"/>
            <!-- 指定用来初始化数据库数据的sql文件 -->
            <jdbc:script location="classpath:data.sql"/>
        </jdbc:initialize-database>
    </beans>
    ```
    ```sql
    ##### schema.sql
    CREATE TABLE 
        ACCOUNT (
            ID BIGINT IDENTITY PRIMARY KEY, 
            OWNER_NAME VARCHAR(255), 
            BALANCE DOUBLE, 
            ACCESS_TIME TIMESTAMP, 
            LOCKED BOOLEAN
        );
    ##### data.sql
    insert into 
        account (id,owner_name,balance,access_time,locked) 
        values (100,'john doe',10.0,'2014-01-01',false);
    ```
    





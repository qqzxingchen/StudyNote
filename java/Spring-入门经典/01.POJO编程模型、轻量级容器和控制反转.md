
### POJO 编程模型
* POJO： Plain Old Java Model，即简单的Java对象
    * 这个概念的目的是为了简化Java应用程序（尤其是企业级Java应用程序）的编码、测试、部署等阶段

* EJB编程模型（原来的）
    * EJB提供了一种组件模式，该模式可以让开发人员仅仅关注系统业务方面的开发，而忽略中间件需求，
        比如组件、事务管理、持久化操作、安全性、资源池、线程、分发、远程处理等，
        开发人员可以非常容易地在任何时候将中间件需求的服务添加到系统中

* POJO编程模型的优点
    * POJO编程模型最重要的优点就是编写应用程序类非常快速和简单，
        这是因为所编写的类不需要依赖任何特定的API，不需要实现任何特定的接口或者扩展自某一特定的框架类，
        开发人员不需要创建任何特殊的回调函数（除非确实需要）
    * 由于基于 POJO 的类不依赖任何特定的API或框架代码，所以可以非常容易地通过网络进行传输，并在不同层之间是使用

### 轻量级容器和控制反转
* 容器
    * 在某一个环境中，所有组件都被创建和装配，并且提供了所需的中间件服务。这样的一个环境被称为容器
    * JavaEE平台就提供了很多这样的容器，每一个专门的容器为应用程序的特定层提供所需的服务
    * 容器举例
        * Servlet容器负责创建和管理应用程序Web层的组件，比如Servlet、JSP、Filter等
        * EJB容器专注于应用程序的业务层，负责管理其EJB组件
        * 与JavaEE平台类似，SpringContainer也是一个容器，在该容器中，应用程序被创建、彼此装配、并以一种轻量级的方式提供中间件服务
    * 任何容器都应该能够向该环境中所管理的组件提供一些基本服务，如：
        * 生命周期管理
        * 依赖解析
        * 组件查找
        * 应用程序配置
    * 如果容器能够提供以下服务，那就更好了：        
        * 事务管理
        * 安全性
        * 线程管理
        * 对象和资源池
        * 对组件的远程访问
        * 通过JMX之类的API管理组件
        * 容器的扩展和定制
    * 轻量级容器
        * 一个轻量级的容器包括以上所有功能，但并不需要为了依赖这些API而编写应用程序代码。
        * 即轻量级容器没有侵入性，启动非常快，并且不需要将其部署到一个功能齐全的JavaEE应用程序服务器上就能提供上述服务

* 控制反转
    * 容器及其管理的组件提供的最重要的好处就是可插拔的体系结构。
        组件需要实现一些接口，并且可以通过类似的接口访问其他组件所提供的服务。
        组件不需要知道这些服务的具体实现类。也因此可以非常容易地使用一个不同的实现来替换系统中的任何组件。
        而容器的工作则是创建这些组件以及所依赖的服务，并将这些组件组装在一起
    * 在组件类中，不需要使用新的操作符来实例化依赖组件，而是在运行时由容器实例将依赖组件注入组件。
        因此对于依赖项的控制由组件转为容器，这种模式被称为控制反转（Inversion of Control. IoC）
    * 即典型的： do not call me , I will call you
    * IoC 被认为是任何容器都需要提供的基本功能之一，它主要有两种形式
        * 依赖查找:容器向其管理的组件提供了回调方法，而组件则通过这些回调方法与容器进行交互并显式地获取它们的依赖项。
        * 依赖注入:组件提供了合适的构造函数或Setter方法，以便容器可以注入依赖组件。
        * 区别
        ```
        假设现在有 组件A依赖组件B，那么
        依赖查找：组件A通过容器的某种回调函数，显式地告诉容器它依赖于什么组件
        依赖注入：组件A通过提供一些合适的方法（构造函数或Setter方法），由容器调用这些方法并将其依赖的组件B的对象传给组件A
        ```
        * 当前Spring以及其他的轻量级IoC框架使用的都是依赖注入的方法。这时候，组件如何实例化以及需要哪些依赖组件完全由容器自己的配置机制来确定。
            容器的任务是处理相关的配置信息，以便在运行时实例化所需的组件并装配依赖项

### 依赖注入
* 依赖注入的基本原则是，应用程序对象不应该负责查找它们所依赖的资源，而应该由IoC容器处理对象创建和依赖注入，从而实现资源查找的外部化
* 两种依赖注入的方法
    * Setter方法注入
        * 当一个对象被容器实例化之后就会马上调用Setter方法，该注入发生在组件的创建或则初始化阶段发生，并在处理业务方法调用之前完成
        * 优点：组件在创建之后可以进行重新配置，组件的依赖项可以在运行时更改
        * 缺点：并不是所有所需的依赖项都可以在使用前被注入；这将会导致组件处于一种部分配置的状态。
            某些情况下，调用Setter方法的顺序可能非常重要，但是这种顺序却无法在组件约定中描述出来。
    * 构造函数注入
        * 通过构造函数注入，Bean可以利用构造函数参数来表达依赖项，这样就可以在组件创建期间注入依赖项
        * 优点：可以保证容器每一个被管理的组件都处于一致状态，并且在创建之后马上使用。
        * 缺点：组件创建完毕之后无法再对组件进行重新配置，除非为相关属性提供一个Setter作为构造函数参数；此外，继承的时候也可能出现问题
    * 这两种方法都有各自的优缺点，在任何应用程序中只使用一种方法是不可能的。
        * 比如：你可能拥有一些由第三方类，这些类并不具有相关的构造函数来接受适合自己配置情况的合适参数。
            因此可能先创建一个带有一个构造函数的组件，而该构造函数贴近需求的参数。然后再使用Setter方法注入其他的依赖项。
    



# Lock的使用

* ReentrantLock / ReentrantReadWriteLock

## ReentrantLock 

* ReentrantLock 要比 synchronized 更灵活
    * 在使用 notify/notifyAll 方法时，JVM将会随机选择一个合适的线程进行唤醒，然后执行后续操作。
    * 可以使用 ReentrantLock+Condition 类的方式来实现多路通知的功能

* Condition 对象
    * 在一个 Lock 对象中可以创建多个 Condition 实例，
        线程对象可以在指定的 Condition 上进行 await，而只有在该 Condition 被 signal 时，该线程对象才会 signal

* 不同的同步/通知
    * synchronized+Object 实现的同步与 Lock实现的同步
    ```java
    synchronized(obj){
        // do something
    }

    lock.lock();
    // do something
    lock.unlock();
    ```
    * synchronized+Object(wait/notify) 实现的通知与 Lock+Condition(await/signal) 实现的通知
    ```java
    synchronized(obj){
        obj.wait();
    }
    synchronized(obj){
        obj.notify();
    }

    lock.lock();
    condition.await();
    lock.unlock();

    lock.lock();
    condition.signalAll();
    lock.unlock();
    ```

* 完整的例子

```java
public class UseConditionWaitNotify {
    public static class MyService{
        private Lock lock = new ReentrantLock();
        private Condition condition = lock.newCondition();
        public void await(){
            try {
                lock.lock();
                System.out.println( "before await 时间为 " + System.currentTimeMillis() );
                condition.await();
                System.out.println( "after await 时间为 " + System.currentTimeMillis() );
            }catch (InterruptedException e){ e.printStackTrace(); }
            finally { lock.unlock(); }
        }
        public void signal(){
            try {
                lock.lock();
                System.out.println( "before signal 时间为 " + System.currentTimeMillis() );
                condition.signal();
                System.out.println( "after signal 时间为 " + System.currentTimeMillis() );
            }finally { lock.unlock(); }
        }
    }
    @AllArgsConstructor
    public static class ThreadA extends Thread{
        private MyService myService;
        @Override
        public void run(){
            this.myService.await();
        }
    }
    public static void main(String[] args) throws Exception{
        MyService myService = new MyService();
        ThreadA threadA = new ThreadA( myService );
        threadA.start();
        Thread.sleep( 3000 );
        myService.signal();
    }
}
```

## 公平锁与非公平锁

* 锁 Lock 分为 “公平锁” 与 “非公平锁”
    * 公平锁： 线程获取锁的顺序，是按照现场加锁的顺序来的，即 FIFO 的队列
    * 非公平锁： 即锁的抢占机制，谁抢到就是谁的（即随机地，不取决于加锁的先后顺序）
    * 可以通过 `new ReentrantLock(isFair)` 来构建公平锁或者非公平锁

## ReentrantReadWriteLock

* ReentrantLock 具有完全排他的效果，接同一时间只能有一个活动的线程在执行 ReentrantLock.lock() 之后的任务；
    在一些允许少写多读的场景中，这种锁的性能会很低下，因此引入了 ReentrantReadWriteLock。

* ReentrantReadWriteLock
    * 读写锁包含了两个锁
        * 读锁 -- 共享锁
        * 写锁 -- 排他锁
        * 特性：多读之间不互斥；读写之间互斥；多写之间互斥


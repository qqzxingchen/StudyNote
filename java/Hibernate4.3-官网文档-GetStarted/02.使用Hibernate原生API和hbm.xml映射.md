
### Hibernate 配置文件
* hibernate.cfg.xml 定义了Hibernate 的配置信息
    * | 属性名 | 描述 |
      |:--|:--|
      | connection.driver_class | 连接数据库用的驱动 |
      | connection.url          | 数据库地址 |
      | connection.username     | 用户名 |
      | connection.password     | 密码 |
      | connection.poll_size    | 配置 Hibernate 的内建里连接池的连接数量 |
      | dialect                 | SQL 的方言 |
      | hbm2ddl.auto            | 支持自动将数据库模式生成到数据库中 |
    * JDBC 连接信息（ driver_class、url、username、password ）
        * Hibernate使用内存数据库 H2 ，因此下面的配置实际上都是为了运行H2的
    * 注意，内置的Hibernate连接池不能用于生产使用；相比于生产环境的连接池，它少了很多特性

### Java实体类
* 这里说的是 org.hibernate.tutorial.hbm.Event 类
    * 此类中属性的getter和setter方法使用了标准的JavaBean命名约定，以及字段的私有可见性。
    * 无参构造器，也是JavaBean惯例，是所有持久化类的要求。Hibernate需要使用Java Reflection为你创建对象。
        构造函数可以是私有的。 但是，运行时代理生成和高效的数据检索需要包或公共可见性，无需字节码检测。

### 映射文件
* 映射文件 org/hibernate/tutorial/hbm/Event.hbm.xml
    * Hibernate 通过映射元数据决定如何加载和保存对象。通过映射文件可以向Hibernate提供映射元数据
    ```xml
    <!-- 其中 name 字段描述了实体类，table字段描述了数据库中相应的数据表 -->
    <class name="Event" table="EVENTS">
        <!-- name字段是实体类中的属性，column字段是数据库中关联起来的属性 -->
        <id name="id" column="EVENT_ID"></id>
        <!-- 
            由于date字段在很多数据库中都是保留字段，因此这里需要为其指定一个其他的column 
            type 字段，在这里既不是指 Java 的数据类型，也不是 SQL 的数据类型；而是Hibernates的映射类型。
                它在这里做的是 Java 到 SQL 的类型转换（比如date属性，Hibernate并不知道应该将java.util.Date对象映射到SQL的DATE数据类型、还是TIME数据类型、还是TIMESTAMP数据类型）
        -->
        <property name="date" type="timestamp" column="EVENT_DATE"/>
        <!-- 如果没有指定column，则认为column与name的值相同 -->
        <property name="title"/>
    </class>
    ```

### 实例代码
* 测试类 org.hibernate.tutorial.hbm.NativeApiIllustrationTest
```java
package org.hibernate.tutorial.hbm;

import org.hibernate.cfg.Configuration;
import org.junit.Test;

public class NativeApiIllustrationTest {
    protected void setUp() throws Exception {
        // 一个应用程序应该只初始化一个 SessionFactory （sessionFactory 对象是线程安全的）
        // new Configuration().configure() : 从 hibernate.cfg.xml 配置文件中读取配置
        SessionFactory sessionFactory = new Configuration().configure().buildSessionFactory();

        // 使用 Session 工厂来创建一个 session
        Session session = sessionFactory.openSession();

        // 开始一个事务
        session.beginTransaction();

        // 保存两个实体到数据库
        session.save( new Event( "Our very first event!", new Date() ) );
        session.save( new Event( "A follow up event", new Date() ) );

        // 提交一个事务
        session.getTransaction().commit();
        session.close();
    }

    protected void readData() throws Exception{
        session = sessionFactory.openSession();
        session.beginTransaction();

        // 使用 Hibernate 的query语句（HQL）加载所有的Event数据
        List result = session.createQuery( "from Event" ).list();
        for ( Event event : (List<Event>) result ) {
            System.out.println( "Event (" + event.getDate() + ") : " + event.getTitle() );
        }
        session.getTransaction().commit();
        session.close();

    }

}
```



